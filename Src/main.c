/*
 	 Подключение:
 	 * светодиоды - PB3 - PB6;
 	 * кнопки - PC13-PC15
 */
#include "stm32g431xx.h"

void dummy_delay(int32_t duration);

// Объявления, необходимые для настройки порта B. Нужно поменять на значения, которое бы настроили все 4 ноги на выход.
#define GPIOB_RESET_MASK 		(0x03C0)
#define GPIOB_SET_MASK			(0x0140)



int main(void)
{
	/*
 	 	 Включение FPU - ускорителя операций с плавающей точкой. В это вообще не стоит пока лезть,
	но без этого микроконтроллер не будет работать, если в коде будут операции с float или double.
	 */
	SCB->CPACR |= 0x3 << 20 ;  	//


	/*
		Включенеи тактирования портов B и C, скотороыми мы работаем в этом коде. Каждая периферия тактируется (получает тактовые сигналы от источника) отдельно
	для экономии энергии. Соответственно без тактирования периферия не работает. С этим пока не надо разбираться. Просто факт.

	Что важно! Важно понять, с чем мы вообще в коде имеем дело. Что такое RCC, что такое AHB2ENR и что это за странная запись вида RCC_AHB2ENR_GPIOBEN.

	По виду записи можно понять, что RCC - указатель на структуру с полем AHB2ENR. Если нажать на левый CTRL и на название RCC можно перейти в место, где происходит
	объявление этой структуры. Там много всего очень страшного и я просто объясню, что происходит. Регистр это физическое место памяти микроконтроллера объемом
	32 бита, то есть 4 байта (это справедливо именно для STM32 микроконтроллеров и может отличаться у других) соответственно все регистры, описанные в документации
	имеют какой-то конкретный адрес в памяти контроллера, и всегда, регистры описывающие одну периферию располагаются друг за другом. Соответственно конкретные адреса
	и положения можно увидеть в документации. Суть в том, что поля структуры расположены так, что если указатель на структуру указывает на первый регистр, то на него будет
	указывать первое поле, и соответственно второе поле будет указывать на второй регистр и так далее. Это очень удобно. Все в CMSIS оформлено по такой схеме:
	Периферии в документации соответствуют указатели в CMSIS библиотеке (которую мы подключаем через файл stm32g431.h). Соответственно полня в структурах соответствую полям
	в документации и мы можем в наглядном виде представить, что и куда записываем.

	Что такое RCC_AHB2ENR_GPIOBEN - это #define, которая скрывает в себе маску, которую нужно записать в регистр RCC-AHB2ENR чтобы включить тактирование порта
	Чтобы в этом убедиться можно навести на нее мышку и задержать (будет показан вид #define-операции) либо можно зажать CTRL и нажать мышкой на название и нас
	перенесет к моменту объявления. #define (объявления) очень мощный инструмент, который позволяет заменять записи вида 0x0FC0 в которых ничего не понятно
	на читаемые и понимаемые записи, которые улучшают чистоту и качество кода. В дальнейшем, мы будем использовать такие записи повсеместно.
	 */
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN | RCC_AHB2ENR_GPIOCEN; 	//

	// В данном случае мы настраиваем входы и выходы. При этом мы настраиваем порт B с использованием define, а порт С без
	GPIOB->MODER &= ~GPIOB_RESET_MASK;
	/*
		Записи выше и ниже этого комментария полностью эквивалентны. Можно выбрать любую из них и код будет работать. При это запись сверху использует наше
	собственное придуманное объявление, а запись ниже уже имеющиеся в CMSIS объявления. Запись ниже является очень информативной так как сразу показывает
	что мы отнимаем от регистра маску 3ей и 4ой ножки, что сразу упрощает понимание кода. Кроме этого, данные код становится более универсальным и переносимым
	Так как конкретные значения спрятанные под GPIO_MODER_MODE3_Msk могут поменяться, но сам define всегда будет присутствовать в CMSIS, что говорит о том, что
	мы можем не бояться переносить код между различными семействами микроконтроллеров. В общем случае удобно использовать объявления от CMSIS, когда это удобно,
	проблема в том, что удобно это далеко не всегда, и в таких случаях нужно стараться придумывать свои универсальные инструменты максимально направленные на то
	чтобы сделать код понятным для чтения другими разработчиками (это один из самых важных критериев - читабельность кода).

	*/
//	GPIOB->MODER &= GPIO_MODER_MODE3_Msk | GPIO_MODER_MODE4_Msk;
		GPIOB->MODER |= GPIOB_SET_MASK;

	GPIOC->MODER &= ~0x0C000000; // PC13 используем как цифровой вход. Тут нам не нужно делать вторую команду. Вопрос, почему? (ответить личным сообщением)


	// Включаем светодиод чтобы видеть, что плата работает
			GPIOB->ODR |= 0x08;


	// Данный алгоритм зажигает второй светодиод на плате, если нажата крайняя левая кнопка и тушит его, если она отжата

	while (1)
	{
		/*
		Пока я не дам тебе электрическую схему и не буду объяснять что такое дребезг кнопок. Сейчас самое важно - понимать как работает кнопка, установленная на плате.
	Из-за специфики подключения кнопки к микроконтроллеру, когда кнопка не нажата на цифровом входе присутствует "1", а когда кнопка нажата "0". Соответственно нам
	надо проверить, если конкретная ножка в порту равно "0". Важно понимать что в Си операция if сработает, если условие будет не равно 0 (при этом не важно, если условие
	будет равно 1, 40, 50, оно все равно сработает) и не сработает ТОЛЬКО тогда, когда равно 0.
		Соответственно мы хотим проверить состояние ножки 13 порта C. Для этого мы делаем операцию & с маской 0x2000, то есть мы приравниваем 0 все ножки кроме 13-ой,
		а ее состояние оставляем таким, какое оно есть. И потом проверяем. Если состояние равно "1" - кнопка не нажата из-за специфики подключения, значит надо выключить
		соответствующий светодиод. Если кнопка нажата, условие будет равно 0 и при его инверсии мы получаем не 0, соответственно надо включить светодиод
		 */
		if(!(GPIOC->IDR & 0x2000))
		{
			GPIOB->ODR |= 0x10;
		}
		else
		{
			GPIOB->ODR &= ~ 0x10;
		}

		// Делаем небольшую задержку просто чтобы была и чтобы не гонять включение и выключение слишком часто, от части это спасает от дребезга, а котором потом
		dummy_delay(10000);
	}
}

// Все еще очень ленивая функция задержки
void dummy_delay(int32_t duration)
{
	for(int32_t time = 0; time < duration; ++time);
}


